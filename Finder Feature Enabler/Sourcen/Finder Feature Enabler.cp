/*** *	Finder Feature Enabler.cp * *	(c)1996 Maxon, Markus Fritze ***/#include <Gestalt.h>#include <A4Stuff.h>/*** *	einen Gestalt-Selector abfragen ***/static long				GetGestalt(OSType iSelector){long		theResponse;	if(::Gestalt(iSelector, &theResponse) != noErr)		theResponse = 0L;	return theResponse;}/*** *	ControlRef eines Items in einer Dialogbox *	ermitteln ***/static ControlRef	GetItemHandle(const DialogPtr iDialog, const short iItemNo){short	theItemType;Handle	theItem;Rect	theBox;	::GetDialogItem(iDialog, iItemNo, &theItemType, &theItem, &theBox);	return ControlRef(theItem);}/*** *	Titel eines Controls neu setzen ***/static void				SetItemTitle(const DialogPtr iDialog, const short iItemNo, SInt16 iIndex, SInt16 iLanguage){	Str255	theString;	theString[0] = 0;	GetIndString(theString, -4048 + iLanguage, iIndex);	if(theString[0] == 0)		GetIndString(theString, -4048, iIndex);	SetControlTitle(GetItemHandle(iDialog, iItemNo), theString);}/*** *	Checkbox abfragen ***/static Boolean			GetCheck(const DialogPtr iDialog, short iItemNo){	return ::GetControlValue(GetItemHandle(iDialog, iItemNo)) != 0;}/*** *	Checkbox setzen ***/static void				SetCheck(const DialogPtr iDialog, short iItemNo, Boolean iCheck, Boolean iDisable = false){	ControlRef	theCH = GetItemHandle(iDialog, iItemNo);	SInt16			thePart = kControlNoPart;	if(iDisable) {		thePart = kControlInactivePart;		iCheck = false;	}	::HiliteControl(theCH, thePart);	::SetControlValue(theCH, iCheck);}/*** *	Versionsnummer des Finders ermitteln ***/static UInt16			GetFinderVersion(){	static FSSpec	theFinder = { 0, 0, "\pFinder" };	OSErr	iErr = FindFolder(kOnSystemDisk, kSystemFolderType, kDontCreateFolder, &theFinder.vRefNum, &theFinder.parID);	if(iErr) return 0x0000;	short	fRefNum = FSpOpenResFile(&theFinder, fsRdPerm);	if(fRefNum == -1) return 0x0000;	Handle	hRsrc = Get1Resource('vers', 1);	UInt16	theVersion = 0x0000;	if(hRsrc)		theVersion = **static_cast<short**>(hRsrc);	CloseResFile(fRefNum);	return theVersion;}/*** *	Eine Applikation in der Prozessliste nach *	ihrem Filetype und Creator suchen. ***/static OSErr			FindAProcess(OSType iType, OSType iCreator, ProcessSerialNumberPtr oProcessSN){ProcessInfoRec	theProcessInfo;FSSpec			theProcessFSSpec;Str31			theProcessName;OSErr			theErr = noErr;	// start at the beginning of the process list	oProcessSN->lowLongOfPSN = kNoProcess;	oProcessSN->highLongOfPSN = kNoProcess;	// initialize the process information record	theProcessInfo.processInfoLength = sizeof(ProcessInfoRec);	theProcessInfo.processName = (StringPtr)&theProcessName;	theProcessInfo.processAppSpec = &theProcessFSSpec;	while((theProcessInfo.processSignature != iCreator || theProcessInfo.processType != iType) || theErr != noErr) {		theErr = GetNextProcess(oProcessSN);		if(theErr == noErr)			GetProcessInformation(oProcessSN, &theProcessInfo);	}	return theErr;}/*** *	Unsere Konstanten für das Senden von *	AppleEvents an den Finder. Siehe auch *	Kapitel 8 des Apple Event Registry ***/const OSType		kFinderSig = 'FNDR';const OSType		kSystemType = 'MACS';/*** *	Den Finder per AppleEvent beenden ***/static OSErr		AEQuitFinder(){// Der erstellte EventAppleEvent			theEvent;// Descriptor der Prozessnummer des FindersAEDesc				theAddressDesc;ProcessSerialNumber theProcess;OSErr				theErr;	// Prozessnummer des Finders ermitteln	if(FindAProcess(kFinderSig, kSystemType, &theProcess))		return procNotFound;	// Seriennummer in einen Descriptor packen	// um ein Ziel für den Apple Event zu	// definieren	theErr = AECreateDesc(typeProcessSerialNumber, (Ptr)&theProcess, sizeof(theProcess), &theAddressDesc);	if(theErr) return theErr;	// Apple Event erstellen	theErr = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &theAddressDesc, kAutoGenerateReturnID, kAnyTransactionID, &theEvent);	if(theErr) return theErr;	// und abschicken...	theErr = AESend(&theEvent, nil, kAENoReply |					kAEAlwaysInteract | kAECanSwitchLayer,					kAENormalPriority, kAEDefaultTimeout,					nil, nil);	// hier kommen wir wohl nie an, da der Finder	// auch alle Kontrollfelder beendet und somit	// auch uns. Falls es jedoch einen Fehler gibt	// laden wir sehr wohl hier!	AEDisposeDesc(&theEvent);	return theErr;}/*** *	unser cdev-Funktionsdispatcher ***/pascal long	main(short iMessage, short iItem,					short iNumItems, short iPrivate,					const EventRecord *iEvent,					long iStorageValue, DialogPtr iDialog){#pragma unused (iNumItems, iPrivate)#pragma unused (iEvent, iStorageValue)	EnterCodeResource();	// Länder-Code des aktiven Systems ermitteln	SInt16	theLanguage = GetScriptVariable(smSystemScript, smScriptLang);	switch(iMessage)	{	// Test, ob das Kontrollfeld auf diesem Rechner	// läuft:	case macDev:		ExitCodeResource();		// wir setzen einfach mal System 7.1.2 voraus		return GetGestalt(gestaltSystemVersion) >= 0x712;		// Initialisierung	case initDev:		UInt16	theFinderVersion = GetFinderVersion();		UInt32	theVal1 = GetGestalt(0x666E64C5L);		SetCheck(iDialog, 4, (theVal1 & 0x01) == 0x01, theFinderVersion < 0x712);		SetCheck(iDialog, 5, (theVal1 & 0x02) == 0x02, theFinderVersion < 0x751);		SetCheck(iDialog, 6, (theVal1 & 0x04) == 0x04, theFinderVersion < 0x755);		SetCheck(iDialog, 7, (theVal1 & 0x08) == 0x08, theFinderVersion < 0x755);		SetCheck(iDialog, 8, (GetGestalt(0x666E64B5L) & 0x01) != 0x01, (theFinderVersion < 0x754 || GetGestalt(gestaltSystemVersion) < 0x753) || GetGestalt(gestaltSysArchitecture) != gestaltPowerPC);		// Buttons übersetzen		for(int theIndex=1; theIndex<=5; theIndex++)			SetItemTitle(iDialog, theIndex + 3, theIndex, theLanguage);		// INIT nicht installiert?		if(GetGestalt('FPat') == 0L) {			// dann den Update Button disablen			::HiliteControl(GetItemHandle(iDialog, 3), kControlDisabledPart);		}		break;	// Ein Item wurde angeklickt	case hitDev:		if(iItem >= 4 && iItem <= 8) // Checkboxes		{			// Checkbox togglen			SetCheck(iDialog, iItem, !GetCheck(iDialog, iItem));			long *thePref = static_cast<long*>(GetGestalt('FPat'));			if(thePref) {				if(iItem < 8) {					// Bitmaske mit den Flags					thePref[0] &= ~(1 << (iItem - 4));					if(GetCheck(iDialog, iItem))						thePref[0] |= 1 << (iItem - 4);				} else {					// Translucent dragging aus					thePref[1] = 0x0FL;					if(GetCheck(iDialog, 8))						thePref[1] = 0x00L; // an				}			}			// Voreinstellungen in der Resource updaten			long		**thePrefH = static_cast<long**>(GetResource('Pref', -4048));			if(thePrefH) {				(*thePrefH)[0] = thePref[0];				(*thePrefH)[1] = thePref[1];				Handle	theH = static_cast<Handle>(thePrefH);				ChangedResource(theH);				WriteResource(theH);				ReleaseResource(theH);			}		} else if(iItem == 3) { // Update			// noch eine Sicherheitsabfrage			Handle	h = GetResource('ALRT', -4048 + theLanguage);			if(h) {				ReleaseResource(h);			} else {				theLanguage = 0;			}			if(CautionAlert(-4048 + theLanguage, nil) == 1)				AEQuitFinder();		}		break;#if 0	case closeDev:	// Kontrollfeld schließen	case nulDev:	// Null-Event	case updateDev:	// Update-Event	case activDev:	// Activate-event	case deactivDev:// Deactivateevent	case keyEvtDev:	// Key down/auto-Event	case cursorDev:	// Mauscursor setzen	// Ein Menüpunkt aus dem Bearbeiten Menü wurde	// gewählt:	case undoDev:					case cutDev:	case copyDev:	case pasteDev:	case clearDev:		break;#endif	}	ExitCodeResource();	// Wir haben keine Daten alloziert	return cdevUnset;}